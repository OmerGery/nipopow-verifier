\chapter{Implementation}

In this chapter, we put forth out implementation. First, we present our
analysis of the previous work. Then we describe our

\section{Analysis of Previous Work}

In this section, we analyse the verifier by Christoglou et. al. First we
discuss the process needed to prepare the code for our analysis. Then, we show
the gas usage of all internal functions of the verifier.  Finally, we present
the vulnerabilities we discovered, and how we mitigated them in our work.

\subsection{Porting from old Solidity version}

We used the latest version of Solidity compiler for our analysis. To perform
the analysis, we needed to port the verifier from version Solidity 0.4 to
version 0.6.  The changes we needed to perform were mostly syntactic. These
includes the usage of \texttt{abi.encodePacked}, explicit \texttt{memory} and
\texttt{storage} declaration and explicit cast from \texttt{address} to
\texttt{payable address}. We also used our configured EVMs with EIP 2028
enabled to benefit from low cost function calls. The functionality of the
contract remained equivalent.

\subsection{Gas analysis}

Our profiler measures gas usage per line of code. This is very helpful to
observe detailed gas consumption of a contract. Also, we used build-in Solidity
events to measure aggregated gas consumption of different high-level
functionalities. For our experiment we used a chain of 35 blocks, forked at
index 15 with additional 10 blocks as displayed in Figure
\ref{figure:proofs_25-10+20}. The gas usage of each functionality is shown in
Table \ref{table:old_gas_usage}.

\input{figures/proofs_25-10+20.tex}
\input{tables/old_gas_usage.tex}

We used a scenario in which the original proof is flawed and successfully
contested. We selected this scenario because it includes both phases (submit
and contest) and provides full coverage of contest phase since all operations
are executed. For submit phase, the contract needed 10 million gas units, and
for contest phase it needed almost 13 million gas units. Although this size
only represents a very small faction of the real chain, the gas numbers already
exceed the block gas limit of Ethereum, which is a slightly below 10 million.
In figure \ref{figure:old_gas_per_size} we show the gas corresponding to
fluctuates to different chain and proof sizes relatively to the block gas
limit.


\subsection{Security Analysis}

\subsubsection{Pre-mining} We observed that the smart contract is vulnerable to
pre-mining(ref). By definition, a NIPoPoW is structurally correct if two
properties are satisfied:

\begin{enumerate}[(a)]

\item The interlink structure of all blocks is correct. This is to prevent
    adversaries from injecting blocks that do not exist in the original
    blockchain.

\item The first block of proof is $genesis$. This is to prevent adversaries
    from create coins before blockchain are advertised at the public network.

\end{enumerate}

The second property is not verified in the previous work, exposing the verifier
to pre-mining attacks. We can easily mitigate this vulnerability by
initializing the smart contract with the $genesis$ block of the blockchain we
will use and add an assertion in submit and contest phase that proofs need to
satisfy property (b). The needed changes are shown in
Algorithms~\ref{algo:avoid_premining_ctor}
and~\ref{algo:avoid_premining_submit}.

\input{algorithms/avoid_premining.tex}

\subsubsection{Score Calculation}

During our tests, we observed that the calculation of proofs score was
incorrect. The score of each level is needed to determine which proof
represents the chain with the most Proof of Work. Between two proofs, we only
need to calculate the score starting from their $lca$ until the tip of each
proof. Different levels are needed because the $lca$ between two proofs is only
known when the contesting proof is submitted. The security parameter $m$ needs
to be satisfied for every sub-proof $\pi[:lca]$. We ensure that this is $true$
by creating proofs of multiple levels, so that security parameter $m$ applies,
disregarding $lca$'s position.

\todo{Figure for the need of multiple levels}

Each block has a level, calculated as describe in Section(ref)
\[ level = getLevel(block) \]
Consequently, each level of the proof consists of a number of blocks
$n_{level}$. This number is the sum of blocks of level $\geq$ $level$, i.e.\
block of level $l$ are also blocks of levels $l-1$, $l-2$, etc. The
score of each level is computed as:

\[score_{level} = 2^{level} \times n_{level}\]

After running out tests for the previous implementation, we observed that
function $getLevel(block)$ of the contract was returning $block.level-1$
instead of $block.level$ resulting to incorrect score computation. This can
prevent an honest party from successfully contesting an adversarial proof,
making the contract insecure. The function was refined to return the correct
value.

\section{Storage Elimination}
\todo{Should this be a new section?}

As mentioned above, the bottleneck we had to eliminate was the extensive usage
of storage. We created a new architecture that allow us to discard all
expensive store operations and utilize memory instead. This led to massive
decrease of gas consumption. In this section, we present the difference in gas
usage between storage and memory utilization, and how a NIPoPoW verifier can be
implemented in Solidity without persisting proofs.

\subsection{Storage vs Memory}

We will first demonstrate the difference in gas usage between storage and
memory for a smart contract in Solidity. Suppose we have the following simple
contract:

\lstinputlisting[style=customc, captionpos=b, label={listing:storage_memory},
caption={Solidity test for storage and memory}]{code/StorageVsMemory.sol}
\todo{Highlight code}

Function \texttt{withStorage()} populates an array saved in storage and
function \texttt{withMemory()} populates an array saved in memory. We
initialize the sizes of the arrays by passing the variable \texttt{size} to the
contract constructor. We run this piece of code for \texttt{size} from 1 to
100. The results are displayed at Figure~\ref{figure:memory_vs_storage}. For
\texttt{size} = 100, the gas expended is 53,574 gas units using memory and
2,569,848 using storage which is almost 50 times more expensive. This code was
compiled with Solidity version 0.6.6 with optimizations enabled\footnote{This
version of Solidity compiler, which was the latest at the time this paper was
published, did not optimize-out any of the variables.}. The EVM we used  was
Ganache at the latest Constantinople(ref) fork. It is obvious that if there is
the option to use memory instead of storage in the design of smart contracts,
the choice of memory greatly benefits the users.

\input{figures/memory_vs_storage.tex}

\subsection{Making use of calldata}

In previous work we needed to store submitted proofs in order to proceed to
contest. In this subsection we show an approach to securely verify proofs
without utilizing the persistent storage of the smart contract.

The rationale is to demand from the caller to provide two proofs to the
contract during contest phase: (a) $\pi_{exist}$, which is a copy of the
originally submitted proof $\pi_{orig}$, and (b) $\pi_{cont}$, which is the
contesting proof. Proof $\pi_{orig}$ can be retrieved by observing contract's
\textit{calldata}. We prevent an adversary from malforming $\pi_{exist}$ by
storing the hash of $\pi_{orig}$ to contract's state during submit phase and
then verifying that $\pi_{exist}$ has the same hash. The operation of hashing
the proof and storing the digest is cheap\footnote{By setting $k=6$, $m$ = 13,
a proof for the entire Bitcoin blockchain consists of less than 300
superblocks. The hashing of such a proof costs approximately 300,000 gas
units.} as shown in figure~\ref{figure:hash_proof_gas}. We calculate the digest
of the proof by:

\[\texttt{digest = sha256(abi.encodePacked(proof))}\] The size of the digest of
a hash is 32 bytes. To persist such a small value in contract's memory only
adds a constant, negligible cost overhead to our implementation.

\input{figures/hash_proof_gas.tex}

\subsection{Removing DAG and ancestors}

As shown in table~\ref{table:old_gas_usage}, the most demanding operation is
the creation and population of DAG and ancestors. In this subsection we show
how these two structures can be discarded from the verifier.

\subsubsection{Using subset} Our first realization was that instead of storing the
DAG of $\pi_{exist}$, $\pi_{cont}$, we can require

\[ \pi_{exist}\{:lca_{e}\} \subseteq \pi_{cont}\{:lca_{c}\} \]
where $lca_{e}$ and $lca_{c}$ are the indices of the $lca$ block in
$\pi_{exist}$, and $\pi_{cont}$, respectively. This way we avoid
the demanding need of composing auxiliary structures DAG and ancestors
on-chain. The implementation of \texttt{subset} is displayed in
listing~\ref{listing:subset}. The complexity of the function is
\[ \mathcal{O}(\mid\pi_{exist}[:lca_{e}]\mid + \mid\pi_{cont}[:lca_{c}]\mid) \]

\lstinputlisting[style=customc, captionpos=b, label={listing:subset},
caption={Implementation of subset}]{code/Subset.sol}

\input{figures/subset_usage.tex}

The gas consumption difference between $subset$ and $DAG + ancestors$ is
displayed at figure~\ref{figure:DAG_vs_subset}. $Subset$ solution is
approximately 2.7 times more efficient.

\input{figures/DAG_vs_subset.tex}

\subsubsection{Subset complexity and limitations} Requiring $\pi_{exist}$ to be a subset of
$\pi_{cont}$ greatly reduces gas, but the complexity of the $subset$ algorithm
is high since both proofs have to be iterated from genesis to their respective
$lca$ index. Generally, we expect for an adversary to provide a proof of a
chain that is a fork of the honest chain at some point relatively close to the
tip. This is due to the fact that the ability of an adversary to sustain a fork
chain is exponentially weakened as the honest chain progresses.  This means
that the length of $\pi$, $\mid\pi\mid$ is be considerably close to
$\mid\pi[:lca]\mid$, and the complexity of \texttt{subset()} is effectively
$\mathcal{O}(2\mid\pi\mid)$.

In realistic cases, where the $lca$ lies around index 250 of the proof, the gas
cost of \texttt{subset()} is approximately 20,000,000 gas units, which makes it
inapplicable for real blockchains since it exceeds the block gas limit of
the Ethereum blockchain by far.

\subsubsection{Position of block of interest}

By analyzing the benefits and trade-offs of $subset$, we concluded that there
is a more efficient way to treat storage elimination. In general, the concept
of $subset$ facilitated the case in which the block of interest belongs in the
sub-proof $\pi_{exist}[:lca_{e}]$. But in this case, both $\pi_{exist}$ and
$\pi_{cont}$ contain the block of interest at some index, as can be seen in
figure~\ref{figure:after_subset}. Consequently, $\pi_{cont}$ cannot contradict
the existence of the block of interest and the predicate is evaluated $true$
for both proofs. This means that if (a) $\pi_{exist}$ is structurally correct
and (b) the block of interest is in $\pi_{exist}[:lca_{e}]$, then we can safely
conclude that contesting with $\pi_{cont}$ is redundant. Therefore,
$E_{contest}$ can simply send $\pi_{cont}$[lca:] to the verifier. The
truncation of $\pi_{cont}$ to $\pi_{cont}[lca_{c}:]$ can be easily addressed
from $E_{cont}$, since $\pi_{exist}$ is accessible from the contract's
calldata and both proofs can be iterated off-chain.

\newcommand*{\exist}{$\pi_{exist}$}
\newcommand*{\cont}{$\pi_{cont}^{tr}$}

\subsubsection{Disjoint proofs}

We will refer to the truncated contesting proof as $\pi_{cont}^{tr}$ and to
$lca_{e}$ simply as $lca$. For the aforementioned, the following statements are
true:

\begin{enumerate}[(a)]
    \item  $\pi_{exist}[0]$ = $genesis$
    \item  $\pi_{exist}[lca]$ = $\pi_{cont}^{tr}[0]$
\end{enumerate}

The requirement that needs to be satisfied is
\[\pi_{exist}\{lca+1:\} \cap \pi_{cont}^{tr}\{1:\} = \emptyset \]

The implementation of this operation is shown in
listing~\ref{listing:disjoint}.

\lstinputlisting[style=customc, captionpos=b, label={listing:disjoint},
caption={Implementation for disjoint proofs}]{code/Disjoint.sol}

The complexity of \texttt{disjoint()} is
\[ \mathcal{O}(\mid\pi_{exist}[lca_{e}:]\mid \times
\mid\pi_{cont}^{tr}\mid) \]

\section{Fixing vulnerabilities and restricting gas usage}

% \begin{itemize}
%
%     \item
%         This is not vulnerable to DOS attacks
%
% \end{itemize}
