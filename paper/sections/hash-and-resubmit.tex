\section{The Hash-and-Resubmit Pattern}

In the Ethereum blockchain, the notion of Turing-complete smart contracts was
introduced. In order to prevent accidental of adversarial denial-of-service
phenomena such as infinite loops of code, contract invocations are bounded by
an amount of gas units(ref). Gas consumption determines the cost a user has to
pay in Ether(ref) to perform a function call, and constitutes one of the main
performance criteria of smart contracts. Towards the goal of implementing
gas-efficient smart contracts several patterns have been proposed.

\noindent \textbf{The Pattern.} We introduce a novel design pattern for
Solidity smart contracts that results into massive gas optimization. This
technique, which we term \emph{hash-and-resubmit}, is based on observing public
data of the blockchain in order to leverage \emph{off-chain} operations. By
utilizing \emph{hash-and-resubmit}, the performance of the smart contract is
improved considerably since computations are performed locally by the user, and
gas-heavy storage variables are discarded.

The critical observation we make is that large, immutable input structures,
i.e. static arrays, can be eliminated. This is due to the fact that in the body
of the Ethereum block, information regarding transactions is stored. Nodes have
access to this information which include the signatures and input arguments of
function invocations. Hence, a node can access the information of a transaction
by reading the blockchain instead of invoking contract functions. This type of
off-chain access can be applied by any node.

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=1\columnwidth]{figures/observer-tx.pdf}
    \end{center}
    \caption{Entity 1 makes a function call with arguments arg1 and arg2.
    Entity 2 reads the content of transactions in the block and retrieves the
    input data. Entity 2 can use this data to make a different invocation.}
    \label{fig:observe-tx}
\end{figure}

\input{algorithms/observe-tx}

As an example, we demonstrate a smart contract that implements a game between
two players, $P1$ and $P2$, in which the player with the most valuable array
wins. The contract consists of two phases: (a) Submit phase and (b) Contest
phase.

\noindent \textbf{Submit
phase:} $P1$ submits an N-sized array, $array_1$ and becomes the
$holder$ of the contract.

\noindent \textbf{Contest phase:} $P2$ submits $array_2$. If $array_2$ $>$
$array_1$, then the holder of the contract is changed.

In this example, the comparison $array_1$ $>$ $array_2$ is true if
$array_1$[$i$] $>$ $array_2$[$i$] is true for every $i$ $\in$ $array_1$.length.
However, the pattern is agnostic to the implementation of the operator.

The rationale is to demand from $P2$ to provide two arrays to the contract
during contest phase: (a) $array_1^*$, which is a copy of the
originally submitted array by $P1$, and (b) $array_2$, which is the
contesting array. The challenge here, is twofold:

\begin{enumerate}

    \item Availability: $P2$ must be able to retrieve a valid copy of
        $array_1$, without the need of accessing on-chain data.

    \item Reliability: We must prevent $P2$ from dispatching a malformed
        $array_1^*$ which differs from the originally submitted $array_1$.

\end{enumerate}

As its name suggests, \emph{hash-and-resubmit} technique is performed in two
stages to face these challenges: (a) the \emph{hash} phase, which addresses
\emph{reliability}, and (b) the \emph{resubmit} phase which addresses
\emph{availability}.

\noindent \textbf{Addressing Availability:} During submit-phase, $P1$ make the
function call \texttt{submit}($array_1$). This transaction, which includes the
function signature (\texttt{submit}) and the corresponding data ($array_1$), is
added to a block by a miner.  Due to blockchain's transparency, the observer of
\texttt{submit}, $P2$, retrieves a copy of $array_1$, without the need of
accessing contract data. We denote as the copy of $array_1$ as $array_1^*$.

\noindent \textbf{Addressing Reliability:} We prevent an adversary from
altering $array_1^*$ by storing the hash of $array_1$ in contract's state
during \emph{submit phase}. We make use of the pre-compiled \texttt{sha256}
hash function of Solidity: \[hash = \texttt{sha256}(array_1)\] Then, during
contest phase, a verification is performed by comparing the stored hash of
$array_1$ against the hash of $array_1^*$.  \[\texttt{require}(hash =
\texttt{sha256}(array_1^*)\]
\noindent
The size of the hash is 32 bytes. To persist such a small value in contract's
memory only adds a constant, negligible cost overhead.

\noindent \textbf{Benchmarks.} We show the storage implementation of the
above game in Algorithm~\ref{alg.compare-storage} and the hash-and-resubmit
version in Algorithm~\ref{alg.compare-memory}. The gas consumption of the two
algorithms is displayed in Figure~\ref{fig:har-example}.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=1 \columnwidth]{figures/har-example.pdf}
\end{center}
\caption{Gas-cost reduction using the \emph{hash-and-resubmit} pattern. By
avoiding gas-heavy storage operations, the cost of function invocations is
decreased significantly by 93-95\%.}
\label{fig:har-example}
\end{figure}

By using the hash-and-resubmit, the gas consumption decreased by 93-95\%. This
significantly affects the applicability of the contract. Note that, the storage
implementation exceeds the Ethereum block gas limit\footnote{As of July 2020,
the Ethereum block gas limit approximates 10,000,000 gas units} for arrays of
size 500 and above, contrary to the hash-and-resubmit-optimized version, which
consumes approximately 1/10th of the block gas limit for arrays of 1000
elements.

\noindent \textbf{Enabling NIPoPoWs.} We now present how the
\emph{hash-and-resubmit} pattern can used in the context of the NIPoPoW
superlight client. Similar to the aforementioned example, the NIPoPoW verifier
adheres to a submit-and-contest-phase schema, and the inputs of the functions
are arrays that are processed on-chain.

In \emph{submit-phase}, a \emph{proof} is submitted, which can be contested by
another user in \emph{contest-phase}.  The user that initiates the contest,
needs to monitor the traffic of the smart contract. This is a logical
assumption as mentioned in the NIPoPoW paper. The input of \texttt{submit}
function includes the \emph{proof}, $\pi_{subm}$ that indicates the occurrence
of an \emph{event}, \textbf{e} in the source chain, and the input of
\texttt{contest} function includes the \emph{contesting proof}, $\pi_{cont}$. A
successful challenge of the $\pi_{subm}$ is realized when $\pi_{cont}$ has
better score. The process of score evaluation, which is described in
~\cite{nipopows} is irrelevant to the pattern, and remains unchained.

In previous work~\cite{gglou}, NIPoPoW arrays are stored on-chain during
submit-phase, and are processed during contest-phase. This operation is
performed by utilizing storage, which limits the applicability of the contract
considerably. In Algorithm~\ref{alg:har-nipopow} we show how hash-and-resubmit
pattern can be embedded into the NIPoPoW client. In
Figure~\ref{fig:har-nipopow} we display how the gas consumption differentiates
from previous work for the aggregated cost of submit and contest phase.


\input{algorithms/har-nipopow}

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=1\columnwidth]{figures/har-nipopows.pdf}
    \end{center}
    \caption{Performance improvement using hash-and-resubmit pattern in
    NIPoPoWs related to previous work. The gas consumption decreased by
    approximately 50\%}
    \label{fig:har-nipopow}
\end{figure}
