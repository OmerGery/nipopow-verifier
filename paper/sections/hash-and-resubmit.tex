\section{The Hash-and-Resubmit Pattern}

We now introduce a novel design pattern for Solidity smart contracts that
results into massive gas optimization due to the elimination of expensive
storage operations. We first introduce the pattern, and display how smart
contracts benefit by using it. Then, we proceed into integrating the pattern
into the NIPoPoW client, and we analyze the performance in comparison with
previous work.

\textbf{Motivation.}
It is essential for smart contracts to store data in the blockchain. However,
interacting with the storage of a contract is among the most expensive
operations of the EVM~\cite{wood, buterin}. Therefore, only necessary data
should be stored and redundancy should be avoided when possible. This is
contrary to conventional software architecture, where storage is considered
cheap. Usually, the performance of data access in traditional systems is
related with time. In Ethereum, however, performance is related to gas
consumption. Access to persistent data costs a substantial amount of gas, which
has a direct monetary value. One way to mitigate gas cost of reading variables
from the blockchain is to declare them public.  This leads to the creation of a
\emph{getter} function in the background, allowing free access to the value of
the variable. But this treatment does not prevent the initial population of
storage data, which is significantly expensive for large size of data.

By using the \emph{hash-and-resubmit} pattern, large structures are omitted
from storage entirety, and are contained in memory. When a function call is
performed, the signature and arguments of the function is included in the
transactions field of the body of a block. The contents of blocks are public to
the network, therefore this information is locally available to full nodes. By
simply observing blocks, a node retrieves data sent to the contract by other
users. To interact publicly with this data without the utilization storage, the
node \emph{resends} the observed data to the blockchain. The concept of
resending data is redundant in conventional systems. However, this technique
is very efficient to use in Solidity due to the significantly lower gas cost
of memory operations in relation with storage operations.

\noindent \textbf{Related patterns.} Towards the goal of implementing
gas-efficient smart contracts~\cite{contract-opt-1, contract-opt-2,
slither, madmax}, several patterns have been proposed. Towards eliminating
storage operations using data signatures, the utilization of IPFS~\cite{ipfs}
is proposed by \cite{ipfs-1} and~\cite{ipfs-2}. However, these solutions do not
address availability, which is a main requirement in our application.
\cite{logs} uses logs to replace storage in a similar manner sparing a great
amount of gas.  However, this approach does not address consistency, which is
consists also a critical one of our critical target. Lastly,
~\cite{memory-array} proposes an efficient manner to replace read storage
operations, but does not address write operations.


\begin{figure*}[h]
    \begin{center} \includegraphics[width=0.8\textwidth]{figures/har-pattern.pdf}
    \end{center}

    \caption{The \emph{hash-and-resubmit} pattern. First, an invoker calls
        \proc$_1$($\data_0$). $\data_0$ is processed on-chain and $\data$ is
        generated. The signature of $\data$ is stored in the blockchain as the
        digest of a hash function \textsf{H}($\data$). Then, a full node that
        observes invocations of $\proc_1$ retrieves $\data_0$, and generates
        $\data$ by performing the analogous processing on $\data_0$
        \emph{off-chain}. An adversarial observer potentially alters $\data$ to
        $\data^*$.  Finally, the node invokes $\proc_2$(.). In $\proc_2$, the
        validation of input data is performed, reverting the function call if
        the signatures of $\data$ does not match the signature of the input. By
        applying the \emph{hash-and-resubmit pattern}, only the fixed-size
        signature of $\data$ is stored on the blockchain, replacing arbitrarily
        large structures.}

        \label{fig:har-pattern}
\end{figure*}

\noindent
\textbf{Applicability.}
We now list the cases in which the \emph{hash-and-resubmit} pattern is
efficient to use:

The situations in which the \emph{hash-and-resubmit} pattern can be applied are
the following:
\begin{enumerate}
    \item The application is a Solidity smart contract.
    \item Read/write operations are performed in large arrays that exist in
        storage. Rehashing variables of small size may result to negligible
        gain or even performance loss.
    \item The entity that operates on the structures is a full node and
        observes function calls to the smart contract.
\end{enumerate}

\noindent \textbf{Participants and collaborators.} The first participant is the
smart contract $\contract$ that accepts function calls. Another participant is
the invoker $\invoker$, who dispatches a large array $\data_0$ to $\contract$
via a function \texttt{\proc$_1$}($\data_0$). Note that $\data_0$ is
potentially processed in $\proc_1$, resulting to $\data$. The last participant
is the observer $\observer$, who is a full node that observes transactions
towards $\contract$ in the blockchain. This is possible because nodes maintain
the blockchain locally. After observation, $\observer$ retrieves data $\data$.
Since this is an off-chain operation, a malicious $\observer$ potentially
alters $\data$ before interacting with $\contract$. We denote the
potentially modified $\data$ as $\datas$. Finally, $\observer$ acts as an
invoker by making a new call to $\contract$, \texttt{\proc$_2$}($\datas$). The
verification that $\data = \datas$, which is a prerequisite for the secure
functionality of the underlying contract consists a part of the pattern and is
performed in \texttt{\proc$_2$}.

\noindent \textbf{Implementation.} The implementation of this pattern is
divided in two parts. The first part covers how $\datas$ is retrieved by
$\observer$, whereas in the second part the verification of $\data=\datas$ is
realized. The challenge here is twofold:

\begin{enumerate}

    \item Availability: $\observer$ must be able to retrieve $\data$ without
        the need of accessing on-chain data.

    \item Consistency: $\observer$ must be prevented from dispatching $\datas$
        that differs from the originally submitted $\data$.

\end{enumerate}

\noindent
\emph{Hash-and-resubmit} technique is performed in two
stages to face these challenges: (a) the \emph{hash} phase, which addresses
\emph{consistency}, and (b) the \emph{resubmit} phase which addresses
\emph{availability} and \emph{consistency}.

\noindent \textsf{Addressing availability:} During \emph{hash} phase,
$\invoker$ makes the function call \texttt{\proc}$_1$($\data_0$). This
transaction, which includes a function signature (\texttt{\proc$_1$}) and the
corresponding data ($\data_0$), is added in a block by a miner. Due to
blockchain's transparency, the observer of \texttt{\proc}$_1$, $\observer$,
retrieves a copy of $\data_0$, without the need of accessing contract data. In
turn, $\observer$ performs \emph{locally} the same set of on-chain instructions
operated on $\data_0$ generating $\data$. Thus, availability is addressed
through observability.

\noindent \textsf{Addressing consistency} We prevent an adversary $\observer$
from altering $\datas$ by storing the \emph{signature} of $\data$ in contract's
state during the execution of \texttt{\proc$_1$($\data$)} by $\invoker$. In the
context of Solidity, a signature of a structure is the digest of the
structure's \emph{hash}. The pre-compiled \texttt{sha256} is convenient to use
in Solidity, however we can make use of any cryptographic hash function
\textsf{H()}: \[\textsf{hash} \gets \textsf{H}(\textsf{d})\] Then, in
\emph{rehash} phase, the verification is performed by comparing the stored
digest of $\data$ with the digest of $\datas$.
\[\textsf{require}(\textsf{hash} = \texttt{H}(\datas))\] \noindent In Solidity,
the size of digests is 32 bytes. To persist such a small value in contract's
memory only adds a constant, negligible cost overhead.

We illustrate the application of the \emph{hash-and-resubmit} pattern in
Figure~\ref{fig:har-pattern}.

\noindent \textbf{Sample.} We now demonstrate the usage of the
hash-and-resubmit pattern with a simplistic example. We create a smart contract
that orchestrates a game between two players, $\pla$ and $\plb$. The winner is
the player with the most valuable array. The interaction between players
through the smart contract is realized in two phases: (a) the submit phase and
(b) the contest phase.

\noindent \textsf{Submit phase:} $\pla$ submits an N-sized array, $\arra$ and
becomes the $\holder$ of the contract.

\noindent \textsf{Contest phase:} $\plb$ submits $\arrb$. If
\textsf{compare}($\arrb$, $\arra$) is true, then the $\holder$ of the contract
changes to $\plb$. We provide a simple implementation for \textsf{compare()},
but we can consider any notion of comparison, since the pattern is abstracted
from such implementation details.

We make use of the \emph{hash-and-resubmit} pattern by prompting $\plb$ to
provide \emph{two} arrays to the contract during contest phase: (a) $\arras$,
which is the originally submitted array by $\pla$, possibly modified by $\plb$,
and (b) $\arrb$, which is the contesting array.

We provide two implementations of the above described game.
In Algorithm~\ref{alg:game-storage} we display the storage implementation,
while in Algorithm~\ref{alg:game-memory} we show the implementation
embedding the \emph{hash-and-resubmit} pattern.

\input{algorithms/har-game}

\noindent \textbf{Gas analysis.} The gas consumption of the two above
implementations is displayed in Figure~\ref{fig:har-example}. By using the
\emph{hash-and-resubmit} pattern, the aggregated gas consumption for
\textsf{submit} and \textsf{contest} is decreased by 95\%. This significantly
affects the efficiency and applicability of the contract. Note that, the
storage implementation exceeds the Ethereum block gas limit\footnote{As of July
2020, the Ethereum block gas limit approximates 10,000,000 gas units} for
arrays of size 500 and above, contrary to the optimized version, which consumes
approximately only $1/10^{th}$ of the block gas limit for arrays of 1000
elements.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=1 \columnwidth]{figures/har-example.pdf}
\end{center}
\caption{Gas-cost reduction using the \emph{hash-and-resubmit} pattern (lower
is better). By avoiding gas-heavy storage operations, the aggregated cost of
\textsf{submit} and \textsf{contest} is decreased significantly by 95\%.}
\label{fig:har-example}
\end{figure}

\noindent \textbf{Consequences.} The most obvious consequence of applying the
\emph{hash-and-resubmit} pattern variations is the circumvention of storage
structures, a benefit that saves a substantial amount of gas, especially in the
cases where these structures are large. To that extend, smart contracts that
exceed the Ethereum block gas limit become practical. Furthermore, the pattern
enables off-chain transactions, significantly improving the performance of
smart contracts.

\noindent \textbf{Known uses.} To our knowledge, we are the first to combine
the notion of the transparency of the blockchain with data structures
signatures to eliminate storage variables from Solidity smart contracts by
resubmitting data in a manner that addresses consistency and availability.

\noindent \textbf{Enabling NIPoPoWs.} We now present how the
\emph{hash-and-resubmit} pattern is used in the context of the NIPoPoW
superlight client. The NIPoPoW verifier adheres to a submit-and-contest-phase
schema, and the inputs of the functions are arrays that are processed on-chain.
It consists, therefore, a suitable case for our pattern.

In \emph{submit} phase, a \emph{proof} is submitted. In the case of
falsity, it is contested by another user in \emph{contest} phase. The user that
initiates the contest is a node and monitors the traffic of the verifier.  The
input of \textsf{submit} function includes the submit proof ($\pis$) that
indicates the occurrence of an \emph{event} ($e$) in the source chain, and the
input of \textsf{contest} function includes the contesting proof ($\pic$). A
successful contest of $\pis$ is realized when $\pic$ has a better score. The
score evaluation process is irrelevant to the pattern and remains unchained.
The size of proofs is dictated by the value $m$. We consider $m$ = 15 to be
sufficiently secure.

In previous work, NIPoPoW proofs are maintained on-chain, resulting to
extensive storage operations that limit the applicability of the contract
considerably. In our implementation, proofs are not stored on-chain, and $\pis$
is retrieved by the node from calldata. Since we assume a trustless network,
$\pis$ potentially alters by the node. We denote the potentially changed $\pis$
as $\pisa$. In \emph{contest} phase, $\pisa$ and $\pic$ are dispatched in order
to enable the \emph{hash-and-resubmit} pattern.

For our analysis, we create a chain similar to the Bitcoin chain with the
addition of the interlink structure in each block as in~\cite{gglou}. Our chain
spans 650,000 blocks, which represent a slightly enhanced Bitcoin
chain\footnote{Bitcoin spans 631,056 blocks as on May 2020. Metrics by
https://www.blockchain.com/}. From the tip of our chain, we branch two chains
that span 100 and 200 additional blocks respectively, as illustrated in
Figure~\ref{fig:chains}. Then, we use the smaller chain to create  $\pis$, ,
and the larger chain to create $\pic$. By applying the protocol, $\pis$ is
submitted, and a contest is initiated with $\pic$. The contest is successful,
since $\pis$ represents a chain consisting of fewer blocks than $\pic$,
therefore encapsulating less proof of work. We select this setting as it
provides maximum code coverage, and it descries the most gas-heavy scenario.

In Algorithm~\ref{alg:har-nipopow} we show how \emph{hash-and-resubmit} pattern
is embedded into the NIPoPoW client.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=1\columnwidth]{figures/nipopow-subm-cont}
    \end{center}
    \caption{Forked chains for our gas analysis.}
    \label{fig:chains}
\end{figure}

In Figure~\ref{fig:har-nipopow}, we display how results of the
\emph{hash-and-resubmit} implementation differentiate from previous work for
the aggregated cost of \emph{submit} and \emph{contest} phases.  We observe
that by using the \emph{hash-and-resubmit} pattern, we achieve to increase the
performance of the contract 50\%. This is a decisive step towards creating a
practical superlight client.

\input{algorithms/har-nipopow}

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=1\columnwidth]{figures/har-nipopows.pdf}
    \end{center}
    \caption{Performance improvement using hash-and-resubmit pattern in
        NIPoPoWs compared to previous work for a secure value of $m$ (lower is
        better). The gas consumption is decreased by approximately 50\%.}
    \label{fig:har-nipopow}
\end{figure}
