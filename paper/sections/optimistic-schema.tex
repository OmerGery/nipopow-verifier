\section{Leveraging An Optimistic Schema}

We discussed how the verification in the NIPoPoW protocol is realized in two
phases. In \emph{submit} phase, the verification of the $\pis$ is performed.
This is necessary in order to prevent adversaries from injecting blocks that do
not belong to the chain, or changing existing blocks. A proof is valid for
submission if it is \emph{structurally correct}. Correctly structured
NIPoPoWs has the following requirements:

\begin{enumerate}
    \item The first block of the proof is the genesis block of the underlying
        blockchain.
    \item Every block has a valid interlink.
\end{enumerate}

Asserting the existence of genesis in the first index of a proof is an
inexpensive operation of constant complexity. However, confirming the interlink
correctness of all blocks is a process of linear complexity to the size of the
proof. Albeit the verification is performed in memory, sufficiently large
proofs result into costly submissions. This consists the most demanding
function of \emph{submit} phase. In Table~\ref{tab:valid-interlink-cost} we
display the cost of \textsf{valid-interlink} function which determines the
structural correctness of a proof in comparison with the overall gas used in
\textsf{submit}.

\input{tables/valid-interlink-cost}

\newcommand{\dispute}{\emph{dispute\ }} \noindent \textbf{Dispute phase.} We
observe that the addition of a phase in our protocol alleviates the burden of
verifying all elements of the proof by enabling the indication of an individual
incorrect block. This phase, which we term \dispute phase, leverages selective
verification of the submitted proof at a certain index, which, as a constant
operation, significantly reduces the gas cost of the verification process.

In the protocol where \emph{dispute} is incorporated, when an invalid proof
$\pis$ is submitted by $\es$, and retrieved by a node $\ec$ from the calldata.
Then, the proof is checked for its validity \emph{off-chain}. In order to prove
that $\pis$ is invalid, $\ec$ only needs to indicate the index in which $\pis$
fails the interlink verification. Subsequently, $\ec$ calls
$\textsf{dispute}$($\pisa$, $i$), where $i$ indicates the disputing index of
$\pisa$. Therefore, only one block is interpreted \emph{on-chain}, contrary to
the entire span of $\pisa$.

Note that, this additional phase does not imply increased rounds of
interactions between $\es$ and $\ec$. In the case where $\pis$ is invalidated
by \emph{dispute} phase, \emph{contest} phase is skipped.  Similarly, in the
case in which $\pis$ is structurally correct, but represents a chain that is
not honest, then $\ec$ proceeds directly to \emph{contest} phase.

In Table~\ref{tab:dispute-cost} we display the gas consumption for
two independent cycles of interactions:
\begin{enumerate}
    \item Phases \emph{submit} + \emph{dispute} for a case where $\pis$
is structurally incorrect,
    \item Phases \emph{submit} + \emph{contest} for a case where
$\pis$ is structurally correct, but represents a dishonest chain.
\end{enumerate}
\noindent
In Algorithm~\ref{alg:dispute-best-level}, we show the implementation of
\emph{dispute} phase in \textsf{submit} and \textsf{valid-single-interlink}.


\input{tables/dispute-cost}

\textbf{Processing fewer blocks.} As discussed, \emph{dispute} and
\emph{contest} phases are mutually explosive. Unfortunately, constant-time
verification cannot be applied in a contest without increasing the rounds
of interactions for the users. However, we derive a different major gas
optimization for \emph{contest} phase by observing the process of score
evaluation.

In NIPoPoWs, after the last common ancestor is found, each fork of the proofs
is evaluated in terms of score of proof of work. Each level encapsulates
different amount of proof of work, and the level with the best score is the
representative of the underlying proof. Since the common portion of the two
proofs has the same score, only the disjoint portions need to be addressed.
Consequently, the position of the $\lca$ determines the span of the proofs that
will be included in the score evaluation process. Furthermore, it is impossible
to determine the score of a proof in \emph{contest} phase.

On the contrary, when $\pis$ is known, the score of both proofs can be
calculated. This means that, after $\pis$ is retrieved from the calldata, the
scores of $\pis$ and $\pic$ is known to $\ec$, as well as the level in which
each proof encapsulates the most proof of work. In turn, $\ec$ can only submit
the blocks which consist the best level of $\pic$. The number of these blocks
is constant, because it is determined by the security parameter $m$, which is
irrelevant to the underlying blockchain size.

Calculation of best level of $\pic$ is an \emph{off-chain} process. Naturally,
an adversarial $\ec$ can intentionally dispatch a level of $\pic$ which is
different than the best level. However, this is an irrational act, since
different levels only undermine the score of $\pic$. On the contrary, due to
the consistency property of \emph{hash-and-resumbit}, $\pis$ cannot be altered.
We denote the best level of $\pitr$ as $\pitrl$.

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=1\columnwidth]{figures/blocks-of-best-level.pdf}
    \end{center}
    \caption{Fork of two proofs. Colored blocks after the lca determine the
    score of each proof. Black blocks belong to the level that
    has the best score. Only such blocks are part of the contesting proof.}
    \label{fig:score-at-levels}
\end{figure}

The utilization of \emph{best-level} methodology greatly increases the
performance of the client, because the complexity of the majority of
$\textsf{contest}$ functions is related to the size of $\pic$. In
Table~\ref{tab:best-level-cost}, we demonstrate the difference in
\emph{contest} phase after using \emph{best-level}. We observe that the
performance of most functions is increased by approximately 85\%. This is due
to the fact that the size of $\pic$ is decreased accordingly. For $m=15$,
$\pitrl$ consists of is 31 blocks, while $\pitr$ consists of 200 blocks.
Notably, the calculation of score for $\pitrl$ needs 97\% less gas. We achieve
such a discrepancy because the process of score calculation for multiple levels
demands the temporary use of a hashmap which is a storage structure, in
contrast with the evaluation of score of a individual level which is done
entirely in memory.

\input{tables/best-level-cost}

In Figure ~\ref{fig:dispute-best-level}, we illustrate the performance gain of
the client using \emph{dispute} phase and best-level contesting proof. The
aggregated size of \emph{submit} and \emph{contest} phases is greatly reduced
to 3,500,000 gas. This is critical threshold regarding applicability, since
a cycle of interactions fits effortlessly inside a single Ethereum block.

\input{algorithms/dispute-best-level}

\begin{figure}[!h]
    \begin{center}
        \includegraphics[width=1\columnwidth]{figures/dispute-best-level.pdf}
    \end{center}
    \caption{Caption}
    \label{fig:dispute-best-level}
\end{figure}
