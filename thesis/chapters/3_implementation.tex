\section{Implementation}

\subsection{Environment Set-Up}

\subsubsection{Existing Environments}

The first step towards starting the implementation is to set up a
comfortable and adjustable environment. There are several environments
one can use to build Solidity applications, most popular of which are
Truffle(ref), Remix(ref) and Embark(ref). However, none of the
aforementioned applications delivered the experience we needed in the
scope of our project, due to the lack of speed and customization
options. That led us to the creation of a custom environment for
importing, compiling, deploying and testing smart contracts.

We used Python(ref) to build our environment, since it is a powerful
and convenient programming language, and all of our dependencies had
Python implementations available. We developed our environment in
Linux(ref).

\subsubsection{Dependencies}

The components we used as building blocks are Web3(ref) which is a
powerful library for interacting with Ethereum, the Solidity v0.6.6
compiler(ref), and EthereumTester which is a set of tools for testing
Ethereum-based applications. For the purpose of our project, a private
blockchain running an Ethereum Virtual Machine (EVM) was deployed.
This is a common practice for Ethereum developers since it greatly
facilitates testing procedures. Our environment supports multiple
EVMs, namely Geth(ref), Ganache(ref) and Py-EVM(ref).

\subsubsection{Ethereum Virtual Machines}

All aforementioned EVMs deliver an implementation that complies with
the specifications described at the Ethereum yellow paper(ref).
However, different implementations provide unique attributes to the
developer, each of which helped us to progress effortlessly during
different stages of our work.

\paragraph {Py-EVM:} Py-EVM is an evolving EVM which is created mainly for
testing. The ease of access and use, the configuration freedom of its
underlying test chain and its effectiveness for small sized data helped our
first steps. However, as the input data size started to grow, the effectiveness
of the tool rapidly fell(ref).

\paragraph {Ganache:} Ganache is a popular EVM developed by the Truffle team.
It’s speed and configuration freedom are its main advantages. However, its
extreme memory requirement made it impossible to use when the sizes of the
input became analogous to the Bitcoin blockchain size.

\paragraph {Geth:} Geth is another popular EVM which is created by the Ethereum
team. It supports heavy customization while its memory usage is very limited
compared to Ganache, even for extensive inputs. It is, however, slower than
Ganache.

The set of configurations we used for each EVM can be found in our
public repository(ref).

TODO: insert figure of Py-EVM vs Ganache vs Geth

\subsubsection{Gas Profiling}

Another useful utility we used was solidity-gas-profiler(ref), a profiling
utility by Yushih. This gave us great insights regarding the gas usage across
contract’s functions, and, consequently, helped us target the functionalities
that needed to be refined.

TODO: insert figure of gas profiling

\subsection{Model}

As mentioned above, we used a previous verifier implementation(ref) as
a basis for our implementation. Since we adopted common primitives, we
used some of the tools Giorgos et al.\ used for functionalities such as
constructing blockchains and proofs. For the purposes of our project,
we needed to enhance the functionality of the existing tools in some
cases. We are thankful to the writers for sharing their
implementation. This greatly facilitated our work. Similar to Giorgos
el al., we follow the steps listed below:

\begin{enumerate}
    \item
        Construct a blockchain
    \item
        Construct a proof for an event in the blockchain
    \item
        Verify the proof
\end{enumerate}

In this subsection, we describe the model under which both
implementations were deployed.

\subsubsection{Blockchain}

The tool that creates the blockchain was created by Andrew Miller, one
of the writers of Non-Interactive Proofs of Proof of Work(ref) paper.
The tool is using the Bitcoin library(ref) to construct a blockchain
similar to Bitcoin’s. The interlink pointers are organised into a
merkle tree and the index is determined by their level. For details
regarding the level calculation, see section(ref). The merkle root of
the interlink tree is a 32-bit value, and is included in the
blockheader as an additional value. The new size of the block header
is 112 bytes. In order to ensure security, it is important for the
interlink root to be included in the block header, as it is part of
the proof. Otherwise, attackers could attack the proofs by reordering
or including stray blocks. Miners can easily verify that the merkle
root is correct.

TODO: figure of the blockchain

\subsubsection{Superblock Levels}

We assume that the difficulty target of mined blocks is constant. As
discussed in section(ref), this is not the model of the Bitcoin
blockchain. The definition of superblocks is changed to a simpler
definition and the level is determined by the number of leading zeros
of the block header hash. Although this change does not take into
account the difficulty target, the scoring of proof of work does not
generate security holes in the protocol.

\subsubsection{Proof}

The tool that creates proofs was also created by Andrew Miller. The
prover receives the following inputs:

\begin{itemize}
    \item
        A blockchain with interlinks
    \item
        The security parameter k
    \item
        The security parameter m
\end{itemize}

Security parameters k, m are part of the NIPoPoW model and are
explained in section(ref).

The prover’s output is a proof of proof of work that satisfies the
above security parameters. The prover needed to be enhanced in order
to create special test cases (section(ref)) and enable our optimized
architecture (section(ref)).

TODO: figure of proof

\subsubsection{Verifier}

The goal of the verifier is to accept valid proofs and discard invalid
proofs. A proof is submitted in combination with a predicate. The
proof is considered valid if it is constructively correct and the
predicate is true for the chain described by the proof. The predicate
can represent the existence of an event in the source blockchain, such
as the occurrence of a transaction. In our case, the predicate
indicates the existence of a block in the proof.

The verifier functions in two phases: (a) submit phase and (b) contest
phase. Each phase has different inputs and functionalities, and is
performed by different entities.

\paragraph{Submit phase} During the submit phase, an entity submits a
proof and an event. During this phase, we assume that at least one
honest full node is aware of the submission. This is also a part of
the model of NIPoPoW, and is a logical assumption as explained in the
paper. In order to perform a submission, one must provide a proof and
a predicate. If a certain number of rounds passes without submission
of contestations, the proof is considered valid and the predicate is
considered true. The passing of rounds is indicated by the mining of
new blocks atop of the block containing the submission.

\paragraph{Contest phase} If the submitted proof is invalid (i.e.\ the
predicate is not true for the honest chain), a contesting proof is
submitted, invalidating the original proof and predicate. The
contesting proof is considered better only if it encapsulates more
proof of work than the existing proof, as described in the NIPoPoWs
paper. In order to contest, one must provide a consteting
proof and the predicate that is claimed to be true by the originally
submitted proof. If the contesting proof has better score, then the
predicate is evaluated against the contesting proof.

The correct functionality of the verifier is the following.
\begin{itemize}
    \item
        If an honest party makes a submission and no contestation is
        occured, then the predicate becomes true.
    \item
        If an honest party makes a submission and it is contested by an
        adversary, then the contestation is invalid and the predicate
        remains true.
    \item
        If an adversary makes a submission, then an honest party makes a
        contestation. The contestation invalidates the original submission
        and the predicate becomes false.
    \item
        Adversary submissions not followed by an honest contestation cannot
        take place due to the assumption that at least one honest party
        observes the contract's traffic.
\end{itemize}

\subsection{Previous Implementation}
As mentioned in the NIPoPoWs(ref Algorithm 7) paper, in order to construct a
verifier, a DAG structure needs to be maintained in memory. This structure is
stored in the form of a hashmap, and is used to host blocks of all different
proofs. This process aims to prevent adversarial proofs which are structurally
valid, but blocks are intentionally skipped. Such a scerario is displayed in
Figure~\ref{fig:DAG_usage}. The DAG is used to construct ancestors structure.
By iterating ancestors, we can securely determine the value of the predicate.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=10cm]{DAG_usage}
    \caption{Combination of multiple proofs in a DAG. The red block is the
        block of interest}
    \label{fig:DAG_usage}
\end{figure}

This logic is intuitive and efficient to implement in most traditional
programming languages (C++, JAVA, Python, JavaScript, etc). However, such an
algorithm cannot be efficiently implemented in Solidity as is. This is not
due to the lack of features, such as the existence of hashmaps, but because
Solidity treats storage differently than most programming languages. As
mentioned above(ref) in smart contracts the caller needs to pay in gas the
execution of operations such as accessing and storing data. Reading from and
writing to persistent memory are very expensive operations in Solidity, as
stated in the Ethereum yellow paper(ref). A summary of a gas costs is displayed
in Figure~\ref{fig:gas_prices}. This fact was observed by Giorgos et al.\ and
was recognized as the bottleneck of their application.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=12cm]{gas_prices}
    \caption{Gas prices per operation.}
    \label{fig:gas_prices}
\end{figure}

We describe each phase of the previous implementation in
Algorithms~\ref{algo:submit_old} and~\ref{algo:contest_old}. We highlight
structures that access persistent memory. Note that deleting from persistent
memory is also considered a storage operation

\begin{algorithm}
    \caption{Submit Event Proof}
    \KwIn{$proof$, $predicate$}
    \label{algo:submit_old}
    Assert no other proof is currently submitted for the same $predicate$\\
    Assert that $proof$ is structurally valid\\
    Store $proof$ in $proof_{storage}$\\
    Add $proof$ to $DAG_{storage}$\\
    Compute $ancestors_{storage}$ from $DAG_{storage}$\\
    Evaluate $predicate$ from $ancestors_{storage}$\\
    Store result of evaluation in $predicate_{storage}$\\
    Delete $ancestors_{storage}$\\
\end{algorithm}

\begin{algorithm}
    \caption{Submit Contesting Proof}
    \KwIn{$proof'$, $predicate$}
    \label{algo:contest_old}
    Assert $predicate$ equals $predicate_{storage}$  \\
    Find \textit{lca} between $proof_{storage}$ and $proof'$\\
    Assert $proof’[lca:]$ has better score than $proof_{storage}[lca:]$ \\
    Add $proof’$ to $DAG_{storage}$\\
    Compute $ancestors_{storage}$ from $DAG_{storage}$\\
    Evaluate $predicate$ from $ancestors_{storage}$\\
    Delete $predicate_{storage}$\\
    Delete $ancestors_{storage}$\\
\end{algorithm}

\subsection{Targeting vulnerabilities and costly functionalities}

\begin{itemize}
    \item
        0. Knowledge that extensive gas usage is due to large storage
        allocation
    \item
        1. Make old contract compatible with the last version of solidity
        compiler
    \item
        2. Create tests for all functionalities
    \item
        3. Identify and fix vulnerabilities

        Gas was very high due to storage variables

        Contract is vulnerable to premining
    \item
        4. Profile contract gas usage
    \item
        5. Identify expensive operations
\end{itemize}

\subsection{Fixing vulnerabilities and restricting gas usage}

\begin{itemize}

    \item
        Add verification of genesis
    \item
        Reconsider DAG and ancestors methodology and redesign submission and
        contest schema
    \item
        Submit doesn't need to save in the proof in storage. Contest can
        provide the existing proof during contesting.

    \item
        Use subset: P1\{:lca\} $>$ P2\{:lca\}, P1 is the existing, P2 is the
        contesting

        This prevents expensive storage for DAG and ancestors.

    \item
        Even the check of subset can be skipped. The contesting proof cannot
        benefit from pre-lca malformed proof. If Pa is valid, then we just
        need to check Pb[lca:]

    \item
        This is not vulnerable to DOS attacks

    \item
        Observe the network and contest with the appropriate proof if
        submitted is not correct.

\end{itemize}

\pagebreak
